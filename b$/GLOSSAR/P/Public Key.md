# Public Key (K) = Kontonummer mit Verschlüsselung für Dritte

* [BTC Addresse](../A/Address.md)
* [Private Key](Private%20Key.md)

Der öffentliche Schlüssel ist wie eine Bankkontonummer die ich an Dritte gebe damit sie 
a) wissen wohin sie das Geld senden müssen und 
b) sie die Transaktion damit so verschlüsseln können, dass nur ich diese wieder mit meinem Privaten Schlüssel (engl. = [privat/secret key](Private%20Key.md)) wieder entschlüsseln kann.

Bei Bitcoin ist **die [Blockchain Addresse](../A/Address.md) NICHT mit dem Public Key identisch**! Die [Address](../A/Address.md) ist kürzer und damit bessesr lesbar als der Public Key. Sie wird mittels einer Hashfunktion vom Public Key abgeleitet!

Public Keys sind länger als [Addressen](../A/Address.md) und beginnen mit **02** (even compressed), **03** (odd compressed) oder **04** (long format), währenddem [Addressen](../A/Address.md) mit  **1**, **3**, oder **bc1** und damit immer ohne führende 0 beginnen.

## SchlüsselMathematik
Ein öffentlicher Schlüssel - engl. **Public Key genannt und deshalb oft mit einem GROSSEN `K` dargestellt - wird immer von einem [Private Key](Private%20Key.md)** abgeleitet (bzw. unumkehrbar mit Hilfe der Eliptischen Kurven Mathematik abgeleitet. Die Umkehrfunktion würde darauf hinauslaufen alle möglichen Kombinationen durchzuprobieren wofür die heutige Rechenpower aller Computer (noch) nicht reichen würde. 

Der öffentliche Schlüssel dient der VERSCHLUESSELUNG von Daten durch Dritte, die anschliessend nur noch mit meinem eigenen PRIVATE KEY wieder entschlüsselt werden können. 

## Generating a Public Key
Starting with a private key in the form of a randomly generated number `k`, we multiply it by a predetermined point on the curve called the generator point `G` to produce another point somewhere else on the curve, which is the corresponding public key `K`. 

The generator point is specified as part of the `secp256k1` standard and is always the same for all keys in bitcoin:

{K = k * G}

where k is the private key, G is the generator point, and K is the resulting public key, a point on the curve. 

Because the generator point is always the same for all bitcoin users, a private key k multiplied with G will always result in the same public key K. The relationship between k and K is fixed, but can only be calculated in one direction, from k to K. That’s why a bitcoin address (derived from K) can be shared with anyone and does not reveal the user’s private key (k).

Implementing the elliptic curve multiplication, we take the private key k generated previously and multiply it with the generator point G to find the public key K:

K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
Public key K is defined as a point K = (x,y):

K = (x, y)

where,

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
To visualize multiplication of a point with an integer, we will use the simpler elliptic curve over real numbers—remember, the math is the same. Our goal is to find the multiple kG of the generator point G, which is the same as adding G to itself, k times in a row. In elliptic curves, adding a point to itself is the equivalent of drawing a tangent line on the point and finding where it intersects the curve again, then reflecting that point on the x-axis.

Elliptic curve cryptography: visualizing the multiplication of a point G by an integer k on an elliptic curve shows the process for deriving G, 2G, 4G, as a geometric operation on the curve.

Tip
Most bitcoin implementations use the OpenSSL cryptographic library to do the elliptic curve math. For example, to derive the public key, the function EC_POINT_mul() is used.

## Public key formats
Public keys are presented as either **compressed or uncompressed**.

As we saw previously, the public key is a point on the elliptic curve consisting of a pair of coordinates (x,y). 

It is usually presented with the prefix 04 (uncompressed) followed by two 256-bit numbers: one for the x coordinate of the point, the other for the y coordinate. 

The prefix 04 is used to distinguish uncompressed public keys from compressed public keys that begin with a 02 or a 03.

Here’s the public key generated by the private key we created earlier, shown as the coordinates x and y:

`x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A`

`y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB`

Here’s the same public key shown as an uncompressed 520-bit number (130 hex digits) with the prefix 04 followed by x and then y coordinates, as 04 x y:

`K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A↵
07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB`

### Compressed public keys
Compressed public keys were introduced to bitcoin to reduce the size of transactions and conserve disk space on nodes that store the bitcoin blockchain database. Most transactions include the public key, which is required to validate the owner’s credentials and spend the bitcoin. 

Each public key requires 520 bits (prefix + x + y), which when multiplied by several hundred transactions per block, or tens of thousands of transactions per day, adds a significant amount of data to the blockchain.

As we saw in the section Public Keys, a public key is a point (x,y) on an elliptic curve. Because the curve expresses a mathematical function, a point on the curve represents a solution to the equation and, therefore, if we know the x coordinate we can calculate the y coordinate by solving the equation y2 mod p = (x3 + 7) mod p. **That allows us to store only the x coordinate of the public key point, omitting the y coordinate and reducing the size of the key and the space required to store it by 256 bits**. An almost 50% reduction in size in every transaction adds up to a lot of data saved over time!

**Whereas uncompressed public keys have a prefix of 04, compressed public keys start with either a 02 (even) or a 03 (odd) prefix.**

Let’s look at why there are two possible prefixes: because the left side of the equation is y2, the solution for y is a square root, which can have a positive or negative value. Visually, this means that the resulting y coordinate can be above or below the x-axis. As you can see from the graph of the elliptic curve in An elliptic curve, the curve is symmetric, meaning it is reflected like a mirror by the x-axis. **So, while we can omit the y coordinate we have to store the sign of y (positive or negative);** or in other words, we have to remember if it was above or below the x-axis because each of those options represents a different point and a different public key. When calculating the elliptic curve in binary arithmetic on the finite field of prime order p, the y coordinate is either even or odd, which corresponds to the positive/negative sign as explained earlier. **Therefore, to distinguish between the two possible values of y, we store a compressed public key with the prefix 02 if the y is even, and 03 if it is odd,** allowing the software to correctly deduce the y coordinate from the x coordinate and uncompress the public key to the full coordinates of the point. Public key compression is illustrated in Public key compression.

Here’s the same public key generated previously, shown as a compressed public key stored in 264 bits (66 hex digits) with the prefix 03 indicating the y coordinate is odd:

`K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A`

This compressed public key corresponds to the same private key, meaning it is generated from the same private key. 

However, it looks different from the uncompressed public key. 

More importantly, if we convert this compressed public key to a bitcoin address using the double-hash function (RIPEMD160(SHA256(K))) it will produce a different bitcoin address. 

This can be confusing, because it means **that a single private key can produce a public key expressed in two different formats (compressed and uncompressed) that produce two different bitcoin addresses. However, the private key is identical for both bitcoin addresses.**

**Compressed public keys are gradually becoming the default** across bitcoin clients, which is having a significant impact on reducing the size of transactions and therefore the blockchain. However, **not all clients support compressed public keys yet**. Newer clients that support compressed public keys have to account for transactions from older clients that do not support compressed public keys. This is especially important when a wallet application is importing private keys from another bitcoin wallet application, because the new wallet needs to scan the blockchain to find transactions corresponding to these imported keys. Which bitcoin addresses should the bitcoin wallet scan for? The bitcoin addresses produced by uncompressed public keys, or the bitcoin addresses produced by compressed public keys? Both are valid bitcoin addresses, and can be signed for by the private key, but they are different addresses!

To resolve this issue, when private keys are exported from a wallet, the WIF that is used to represent them is implemented differently in newer bitcoin wallets, to indicate that these private keys have been used to produce compressed public keys and therefore compressed bitcoin addresses. This allows the importing wallet to distinguish between private keys originating from older or newer wallets and search the blockchain for transactions with bitcoin addresses corresponding to the uncompressed, or the compressed, public keys, respectively. Let’s look at how this works in more detail, in the next section.